{"version":3,"sources":["header-anim.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"header-anim.min.js","sourcesContent":["(function() {\n\n    var width, height, largeHeader, canvas, ctx, points, target, animateHeader = true;\n\n    // Main\n    initHeader();\n    initAnimation();\n    addListeners();\n\n    function initHeader() {\n        width = window.innerWidth;\n        height = window.innerHeight;\n        target = {x: width/2, y: height/2};\n\n        largeHeader = document.getElementById('large-header');\n        largeHeader.style.height = height+'px';\n\n        canvas = document.getElementById('demo-canvas');\n        canvas.width = width;\n        canvas.height = height;\n        ctx = canvas.getContext('2d');\n\n        // create points\n        points = [];\n        for(var x = 0; x < width; x = x + width/20) {\n            for(var y = 0; y < height; y = y + height/20) {\n                var px = x + Math.random()*width/20;\n                var py = y + Math.random()*height/20;\n                var p = {x: px, originX: px, y: py, originY: py };\n                points.push(p);\n            }\n        }\n\n        // for each point find the 5 closest points\n        for(var i = 0; i < points.length; i++) {\n            var closest = [];\n            var p1 = points[i];\n            for(var j = 0; j < points.length; j++) {\n                var p2 = points[j]\n                if(!(p1 == p2)) {\n                    var placed = false;\n                    for(var k = 0; k < 5; k++) {\n                        if(!placed) {\n                            if(closest[k] == undefined) {\n                                closest[k] = p2;\n                                placed = true;\n                            }\n                        }\n                    }\n\n                    for(var k = 0; k < 5; k++) {\n                        if(!placed) {\n                            if(getDistance(p1, p2) < getDistance(p1, closest[k])) {\n                                closest[k] = p2;\n                                placed = true;\n                            }\n                        }\n                    }\n                }\n            }\n            p1.closest = closest;\n        }\n\n        // assign a circle to each point\n        for(var i in points) {\n            var c = new Circle(points[i], 2+Math.random()*2, 'rgba(255,255,255,0.3)');\n            points[i].circle = c;\n        }\n    }\n\n    // Event handling\n    function addListeners() {\n        if(!('ontouchstart' in window)) {\n            window.addEventListener('mousemove', mouseMove);\n        }\n        window.addEventListener('scroll', scrollCheck);\n        window.addEventListener('resize', resize);\n    }\n\n    function mouseMove(e) {\n        var posx = posy = 0;\n        if (e.pageX || e.pageY) {\n            posx = e.pageX;\n            posy = e.pageY;\n        }\n        else if (e.clientX || e.clientY)    {\n            posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        target.x = posx;\n        target.y = posy;\n    }\n\n    function scrollCheck() {\n        if(document.body.scrollTop > height) animateHeader = false;\n        else animateHeader = true;\n    }\n\n    function resize() {\n        width = window.innerWidth;\n        height = window.innerHeight;\n        largeHeader.style.height = height+'px';\n        canvas.width = width;\n        canvas.height = height;\n    }\n\n    // animation\n    function initAnimation() {\n        animate();\n        for(var i in points) {\n            shiftPoint(points[i]);\n        }\n    }\n\n    function animate() {\n        if(animateHeader) {\n            ctx.clearRect(0,0,width,height);\n            for(var i in points) {\n                // detect points in range\n                if(Math.abs(getDistance(target, points[i])) < 4000) {\n                    points[i].active = 0.3;\n                    points[i].circle.active = 0.6;\n                } else if(Math.abs(getDistance(target, points[i])) < 20000) {\n                    points[i].active = 0.1;\n                    points[i].circle.active = 0.3;\n                } else if(Math.abs(getDistance(target, points[i])) < 40000) {\n                    points[i].active = 0.02;\n                    points[i].circle.active = 0.1;\n                } else {\n                    points[i].active = 0;\n                    points[i].circle.active = 0;\n                }\n\n                drawLines(points[i]);\n                points[i].circle.draw();\n            }\n        }\n        requestAnimationFrame(animate);\n    }\n\n    function shiftPoint(p) {\n        TweenLite.to(p, 1+1*Math.random(), {x:p.originX-50+Math.random()*100,\n            y: p.originY-50+Math.random()*100, ease:Circ.easeInOut,\n            onComplete: function() {\n                shiftPoint(p);\n            }});\n    }\n\n    // Canvas manipulation\n    function drawLines(p) {\n        if(!p.active) return;\n        for(var i in p.closest) {\n            ctx.beginPath();\n            ctx.moveTo(p.x, p.y);\n            ctx.lineTo(p.closest[i].x, p.closest[i].y);\n            ctx.strokeStyle = 'rgba(156,217,249,'+ p.active+')';\n            ctx.stroke();\n        }\n    }\n\n    function Circle(pos,rad,color) {\n        var _this = this;\n\n        // constructor\n        (function() {\n            _this.pos = pos || null;\n            _this.radius = rad || null;\n            _this.color = color || null;\n        })();\n\n        this.draw = function() {\n            if(!_this.active) return;\n            ctx.beginPath();\n            ctx.arc(_this.pos.x, _this.pos.y, _this.radius, 0, 2 * Math.PI, false);\n            ctx.fillStyle = 'rgba(215,217,249,'+ _this.active+')';\n            ctx.fill();\n        };\n    }\n\n    // Util\n    function getDistance(p1, p2) {\n        return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);\n    }\n\n})();\n"]}